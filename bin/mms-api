#!/usr/bin/env ruby

$LOAD_PATH.unshift(File.dirname(__FILE__) + '/../lib')

require 'mms'
require 'optparse'
require 'terminal-table'
require 'parseconfig'
require 'pathname'

actions_available = ["groups", "hosts", "clusters", "snapshots", "restorejobs", "restorejobs-create"]

app_name = 'mms-api'
app_dscr = "#{app_name} is a tool for accessing MMS API"
app_usage = "#{app_name} command [options]"
app_version = MMS::VERSION
app_commands = "#{actions_available.join(' | ')}"

config = {}
options = {}

config_file = Pathname.new(Dir.home) + app_name.prepend('.')
if config_file.exist?
  config = ParseConfig.new(config_file)
end

optparse = OptionParser.new do |opts|
  opts.banner = "#{app_dscr}\n\nUsage:\n\n\t#{app_usage}\n\nCommands:\n\n\t#{app_commands}\n\nOptions:\n\n"

  options[:username] = config['username']
  opts.on("-u", "--username <string>", "MMS user") do |u|
    options[:username] = u
  end

  options[:apikey] = config['apikey']
  opts.on("-k", "--apikey <string>", "MMS api-key") do |k|
    options[:apikey] = k
  end

  options[:apiurl] = config['apiurl']
  opts.on("-a", "--apiurl <string>", "MMS api url. Full url including version: https://mms.mydomain.tld/api/public/v1.0") do |a|
    options[:apiurl] = a
  end

  options[:group_id] = config['group_id'] || nil
  opts.on("-g", "--group-id <string>", "MMS group id") do |g|
    options[:group_id] = g
  end

  options[:cluster_id] = config['cluster_id'] || nil
  opts.on("-c", "--cluster-id <string>", "MMS cluster id") do |c|
    options[:cluster_id] = c
  end

  options[:all] = false
  opts.on(nil, "--all", "Clears flag of --group-id and -cluster-id") do |all|
    options[:all] = true
  end

  options[:name] = '.*'
  opts.on("-n", "--name <string>", "Filter for resource name using regexp") do |n|
    options[:name] = n
  end

  options[:limit] = config['limit'] || 5
  opts.on("-l", "--limit <int>", "Limit for result items") do |l|
    options[:limit] = l.to_i
  end

  opts.on("-v", "--version", "Version") do |v|
    puts "#{app_name} v#{app_version}"
    exit
  end

  opts.on("-h", "--help", "Show this help") do |h|
    puts opts
    exit
  end
end

begin
  optparse.parse!
  if options[:all] == true
    options[:group_id] = nil
    options[:cluster_id] = nil
  end
  if not options[:username]
    puts "Missing options: MMS username [-u <string>]"
    exit
  end
  if not options[:apikey]
    puts "Missing options: MMS api-key [-k <string>]"
    exit
  end
rescue OptionParser::InvalidOption, OptionParser::MissingArgument
  puts $!.to_s
  puts optparse
  exit
end

begin
  action = (ARGV.first || config['action'] || '').downcase
  raise("Unknown action #{action.upcase}") unless actions_available.include? (action)
rescue => e
  puts "Error: #{e.message}"
  puts "Available actions: #{(actions_available.join ', ').upcase}"
  puts optparse
  exit 1
end

begin
  ARGV.shift
  agent = MMS::Agent.new(options[:username], options[:apikey], options[:group_id], options[:cluster_id])
  if options[:apiurl] then
    agent.set_apiurl(options[:apiurl])
  end

  results = agent.send action.sub('-', '_'), *ARGV
  results.select! { |resource| !resource.name.match(Regexp.new(options[:name])).nil? }

  rows = []
  case action
    when 'groups'
      heading = ['Name', 'Active Agents', 'Replicas count', 'Shards count', 'Last Active Agent', 'GroupId']
      results.each do |group|
        rows << [group.name, group.active_agent_count, group.replicaset_count, group.shard_count, group.last_active_agent, group.id]
      end
    when 'hosts'
      heading = ['Group', 'Type', 'Hostname', 'IP', 'Port', 'Last ping', 'Alerts enabled', 'HostId', 'Shard', 'Replica']
      results.each do |host|
        rows << [host.group.name, host.type_name, host.name, host.ip_address, host.port, host.last_ping, host.alerts_enabled, host.id, host.shard_name, host.replicaset_name]
      end
    when 'clusters'
      heading = ['Group', 'Cluster', 'Shard name', 'Replica name', 'Type', 'Last heartbeat', 'Cluster Id']
      results.each do |cluster|
        rows << [cluster.group.name, cluster.name, cluster.shard_name, cluster.replicaset_name, cluster.type_name, cluster.last_heartbeat, cluster.id]
      end
    when 'snapshots'
      heading = ['Group', 'Cluster', 'SnapshotId', 'Complete', 'Created increment', 'Name (created date)', 'Expires']
      results_sorted = results.sort_by { |snapshot| snapshot.created_date }.reverse
      results_sorted.first(options[:limit]).each do |snapshot|
        rows << [snapshot.cluster.group.name, snapshot.cluster.name, snapshot.id, snapshot.complete, snapshot.created_increment, snapshot.name, snapshot.expires]
        rows << :separator
        part_count = 0
        snapshot.parts.each do |part|
          file_size_mb = part['fileSizeBytes'].to_i / (1024*1024)
          rows << [{:value => "part #{part_count}", :colspan => 4, :alignment => :right}, part['typeName'], part['replicaSetName'], "#{file_size_mb} MB"]
          part_count += 1
        end
        rows << :separator
      end
    when 'restorejobs', 'restorejobs-create'
      heading = ['RestoreId', 'SnapshotId / Cluster / Group', 'Name (created)', 'Status', 'Point in time', 'Delivery', 'Restore status']
      results_sorted = results.sort_by { |job| job.created }.reverse
      results_sorted.first(options[:limit]).each do |job|
        rows << [job.id, job.snapshot_id, job.name, job.status_name, job.point_in_time, job.delivery_method_name, job.delivery_status_name]
        rows << ['', "#{job.cluster.name} (#{job.cluster.id})", {:value => '', :colspan => 5}]
        rows << ['', job.cluster.group.name, {:value => '', :colspan => 5}]
        rows << [{:value => 'download url:', :colspan => 7}]
        rows << [{:value => job.delivery_url, :colspan => 7}]
        rows << :separator
      end
  end

  puts Terminal::Table.new :title => action.upcase, :headings => (heading.nil? ? [] : heading), :rows => rows

  puts 'Default group: ' + options[:group_id] unless options[:group_id].nil?
  puts 'Default cluster: ' + options[:cluster_id] unless options[:cluster_id].nil?

  if !options[:group_id].nil? or !options[:cluster_id].nil?
    puts 'Add flag --all or update --group-id, --cluster-id or update your `~/.mms-api` to see all resources'
  end

rescue => e
  puts "Error: `#{e.message}`"
  exit 1
end
